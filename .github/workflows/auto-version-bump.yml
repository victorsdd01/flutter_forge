name: Auto Version Bump

on:
  pull_request:
    types: [closed]
    branches: [main]
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.github/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  bump-version:
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, 'chore: bump version')) ||
      (github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, 'chore: bump version'))
    runs-on: ubuntu-latest
    steps:
      - name: Debug workflow trigger
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Action: ${{ github.event.action }}"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "PR Title: ${{ github.event.pull_request.title }}"
            echo "PR Merged: ${{ github.event.pull_request.merged }}"
            echo "PR Number: ${{ github.event.pull_request.number }}"
          fi
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "Commit Message: ${{ github.event.head_commit.message }}"
            echo "Commit Author: ${{ github.event.head_commit.author.name }}"
          fi
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get current version
        id: get_version
        run: |
          CURRENT_VERSION=$(grep "version:" pubspec.yaml | cut -d " " -f 2 | tr -d '\r')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse version parts (ej: "1.10.0" -> "1", "10", "0")
          MAJOR=$(echo $CURRENT_VERSION | cut -d '.' -f 1)
          MINOR=$(echo $CURRENT_VERSION | cut -d '.' -f 2)
          PATCH=$(echo $CURRENT_VERSION | cut -d '.' -f 3)
          
          # Increment patch version (1.10.0 -> 1.10.1)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Get PR information
        id: pr_info
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          else
            # For push events, use commit message
            PR_TITLE="${{ github.event.head_commit.message }}"
            PR_BODY=""
            PR_AUTHOR="${{ github.event.head_commit.author.name }}"
          fi
          
          echo "PR Title: $PR_TITLE"
          echo "PR Author: $PR_AUTHOR"
          
          # Use delimiter to handle multiline content safely
          {
            echo "pr_title<<EOF"
            echo "$PR_TITLE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "pr_body<<EOF"
            echo "$PR_BODY"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          echo "pr_author=$PR_AUTHOR" >> $GITHUB_OUTPUT

      - name: Update pubspec.yaml
        run: |
          sed -i "s/version:.*/version: ${{ steps.get_version.outputs.version }}/" pubspec.yaml
          echo "Updated pubspec.yaml:"
          grep "version:" pubspec.yaml

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          PR_TITLE="${{ steps.pr_info.outputs.pr_title }}"
          PR_BODY="${{ steps.pr_info.outputs.pr_body }}"
          DATE=$(date +%Y-%m-%d)
          
          # Clean PR title (remove version tags like [MINOR], [MAJOR], etc.)
          CLEAN_TITLE=$(echo "$PR_TITLE" | sed 's/\[MINOR\]//g' | sed 's/\[MAJOR\]//g' | sed 's/\[PATCH\]//g' | sed 's/\[SKIP\]//g' | xargs)
          
          # Extract changelog content from PR body if it exists
          CHANGELOG_CONTENT=""
          if echo "$PR_BODY" | grep -qiE "## (Changelog|What's New|Changes)"; then
            # Extract content between ## Changelog/What's New/Changes and next ##
            CHANGELOG_CONTENT=$(echo "$PR_BODY" | sed -n '/## [Cc]hangelog\|## [Ww]hat'\''s [Nn]ew\|## [Cc]hanges/I,/^##/p' | sed '/^##/d' | sed '/^$/d' | head -n 10)
          fi
          
          # If no changelog content found, use PR title
          if [ -z "$CHANGELOG_CONTENT" ] || [ "$CHANGELOG_CONTENT" = "" ]; then
            CHANGELOG_CONTENT="- $CLEAN_TITLE"
          else
            # Format the content properly (ensure each line starts with -)
            CHANGELOG_CONTENT=$(echo "$CHANGELOG_CONTENT" | sed 's/^/- /' | sed 's/^- -/-/')
          fi
          
          # Create Python script file
          cat > /tmp/update_changelog.py << 'PYEOF'
          import re
          import sys
          import os
          
          version = os.environ.get('VERSION', '')
          date = os.environ.get('DATE', '')
          changelog_content = os.environ.get('CHANGELOG_CONTENT', '')
          
          # Create new changelog entry
          new_entry = f"""## [{version}] - {date}
          
          ### Changes
          {changelog_content}
          
          """
          
          # Read current CHANGELOG
          with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
              content = f.read()
          
          # Find [Unreleased] section and insert after it
          if '## [Unreleased]' in content:
              # Find the end of [Unreleased] section (after the last item before next ##)
              pattern = r'(## \[Unreleased\].*?\n\n)'
              match = re.search(pattern, content, re.DOTALL)
              if match:
                  # Insert new version after [Unreleased] section
                  insert_pos = match.end()
                  content = content[:insert_pos] + new_entry + content[insert_pos:]
              else:
                  # Fallback: insert after [Unreleased] line
                  content = content.replace('## [Unreleased]', f'## [Unreleased]\n\n{new_entry}', 1)
          else:
              # Insert after header (after line 7)
              lines = content.split('\n')
              lines.insert(8, new_entry.strip())
              content = '\n'.join(lines)
          
          # Write updated content
          with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
              f.write(content)
          
          print(f"âœ… Updated CHANGELOG.md with version {version}")
          PYEOF
          
          # Execute Python script with environment variables
          export VERSION="${{ steps.get_version.outputs.version }}"
          export DATE="$DATE"
          export CHANGELOG_CONTENT="$CHANGELOG_CONTENT"
          python3 /tmp/update_changelog.py
          
          echo ""
          echo "ðŸ“‹ New changelog entry preview:"
          head -n 25 CHANGELOG.md

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Ensure we're on main and up to date
        run: |
          git checkout main
          git pull origin main

      - name: Create version bump branch and commit
        id: version_bump
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="chore/bump-version-$VERSION"
          
          # Ensure we're on main
          git checkout main
          
          # Create and checkout new branch from main
          git checkout -b "$BRANCH_NAME"
          
          # Verify files exist and show current state
          echo "Current pubspec.yaml version:"
          grep "version:" pubspec.yaml || echo "pubspec.yaml not found"
          echo ""
          echo "Current CHANGELOG.md (first 20 lines):"
          head -n 20 CHANGELOG.md || echo "CHANGELOG.md not found"
          
          # Stage changes
          git add pubspec.yaml CHANGELOG.md
          
          # Show what will be committed
          echo ""
          echo "Files staged for commit:"
          git status --short
          
          # Commit changes
          git commit -m "chore: bump version to $VERSION [skip ci]"
          
          # Show commit details
          echo ""
          echo "Commit created:"
          git log -1 --stat
          
          # Push branch
          git push origin "$BRANCH_NAME"
          
          # Verify branch has differences from main
          echo ""
          echo "Checking differences with main:"
          git diff main..HEAD --stat || echo "No differences found"
          
          # Count commits ahead of main
          COMMITS_AHEAD=$(git rev-list --count main..HEAD)
          echo "Commits ahead of main: $COMMITS_AHEAD"
          
          if [ "$COMMITS_AHEAD" -eq 0 ]; then
            echo "âš ï¸ Warning: Branch has no commits ahead of main"
          fi
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="${{ steps.version_bump.outputs.branch }}"
          
          # Create PR using GitHub CLI
          PR_BODY=$(cat <<EOF
          This PR was automatically created to bump the version after ${{ github.event_name == 'pull_request' && format('merging PR #{0}', github.event.pull_request.number) || 'a push to main' }}.
          
          **Changes:**
          - Updated \`pubspec.yaml\` version to \`$VERSION\`
          - Updated \`CHANGELOG.md\` with new release entry
          
          This PR will be auto-merged if branch protection allows.
          EOF
          )
          
          PR_RESPONSE=$(gh pr create \
            --title "chore: bump version to $VERSION [skip ci]" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "automated,chore" \
            --json number,url,state || echo "")
          
          if [ -n "$PR_RESPONSE" ]; then
            PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
            PR_URL=$(echo "$PR_RESPONSE" | jq -r '.url')
            echo "âœ… Created PR #$PR_NUMBER: $PR_URL"
            echo "pull-request-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Failed to create PR or PR already exists"
            echo "pull-request-number=" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-merge PR (if possible)
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pull-request-number }}"
          echo "Attempting to auto-merge PR #$PR_NUMBER..."
          
          # Try to merge the PR
          if gh pr merge "$PR_NUMBER" --auto --squash; then
            echo "âœ… PR #$PR_NUMBER queued for auto-merge"
            
            # Wait and check if PR was merged (poll up to 30 seconds)
            MAX_WAIT=30
            WAITED=0
            while [ $WAITED -lt $MAX_WAIT ]; do
              sleep 2
              WAITED=$((WAITED + 2))
              PR_STATE=$(gh pr view "$PR_NUMBER" --json state --jq '.state')
              if [ "$PR_STATE" = "MERGED" ]; then
                echo "âœ… PR #$PR_NUMBER successfully merged!"
                echo "merged=true" >> $GITHUB_OUTPUT
                
                # Fetch latest changes
                git fetch origin main
                git checkout main
                git pull origin main
                break
              fi
              echo "Waiting for PR to merge... ($WAITED/$MAX_WAIT seconds)"
            done
            
            if [ "$PR_STATE" != "MERGED" ]; then
              echo "âš ï¸ PR #$PR_NUMBER not merged yet (may require manual approval or more time)"
              echo "merged=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Could not auto-merge PR #$PR_NUMBER (may require manual approval)"
            echo "merged=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        id: auto_merge

      - name: Extract release notes from CHANGELOG
        if: steps.auto_merge.outputs.merged == 'true'
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          # Extract the changelog entry for this version
          RELEASE_NOTES=$(awk "/^## \[$VERSION\]/,/^## \[/" CHANGELOG.md | sed '/^## \[/d' | sed '/^$/d' | head -n 20)
          # Escape for JSON
          RELEASE_NOTES_JSON=$(echo "$RELEASE_NOTES" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag
        if: steps.auto_merge.outputs.merged == 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"
          echo "âœ… Created and pushed tag v$VERSION"

      - name: Create GitHub Release
        if: steps.auto_merge.outputs.merged == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: FlutterForge CLI v${{ steps.get_version.outputs.version }}
          body: |
            ## ðŸš€ What's New in v${{ steps.get_version.outputs.version }}
            
            ${{ steps.release_notes.outputs.notes }}
            
            ---
            
            ### ðŸ“¦ Installation
            
            ```bash
            dart pub global activate --source git https://github.com/victorsdd01/flutter_forge.git
            ```
            
            ### ðŸ”„ Update
            
            ```bash
            flutterforge --update
            ```
            
            ### ðŸ“š Full Changelog
            
            See [CHANGELOG.md](https://github.com/victorsdd01/flutter_forge/blob/main/CHANGELOG.md) for the complete list of changes.
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

