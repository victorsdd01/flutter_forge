name: Auto Version Bump

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write
  pull-requests: write

jobs:
  bump-version:
    if: |
      github.event.pull_request.merged == true &&
      !contains(github.event.pull_request.title, '[skip ci]') &&
      !contains(github.event.pull_request.title, 'chore: bump version')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get current version
        id: get_version
        run: |
          CURRENT_VERSION=$(grep "version:" pubspec.yaml | cut -d " " -f 2 | tr -d '\r')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse version parts (ej: "1.10.0" -> "1", "10", "0")
          MAJOR=$(echo $CURRENT_VERSION | cut -d '.' -f 1)
          MINOR=$(echo $CURRENT_VERSION | cut -d '.' -f 2)
          PATCH=$(echo $CURRENT_VERSION | cut -d '.' -f 3)
          
          # Increment patch version (1.10.0 -> 1.10.1)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Get PR information
        id: pr_info
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          
          echo "PR Title: $PR_TITLE"
          echo "PR Author: $PR_AUTHOR"
          
          # Use delimiter to handle multiline content safely
          {
            echo "pr_title<<EOF"
            echo "$PR_TITLE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "pr_body<<EOF"
            echo "$PR_BODY"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          echo "pr_author=$PR_AUTHOR" >> $GITHUB_OUTPUT

      - name: Update pubspec.yaml
        run: |
          sed -i "s/version:.*/version: ${{ steps.get_version.outputs.version }}/" pubspec.yaml
          echo "Updated pubspec.yaml:"
          grep "version:" pubspec.yaml

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          PR_TITLE="${{ steps.pr_info.outputs.pr_title }}"
          PR_BODY="${{ steps.pr_info.outputs.pr_body }}"
          DATE=$(date +%Y-%m-%d)
          
          # Clean PR title (remove version tags like [MINOR], [MAJOR], etc.)
          CLEAN_TITLE=$(echo "$PR_TITLE" | sed 's/\[MINOR\]//g' | sed 's/\[MAJOR\]//g' | sed 's/\[PATCH\]//g' | sed 's/\[SKIP\]//g' | xargs)
          
          # Extract changelog content from PR body if it exists
          CHANGELOG_CONTENT=""
          if echo "$PR_BODY" | grep -qiE "## (Changelog|What's New|Changes)"; then
            # Extract content between ## Changelog/What's New/Changes and next ##
            CHANGELOG_CONTENT=$(echo "$PR_BODY" | sed -n '/## [Cc]hangelog\|## [Ww]hat'\''s [Nn]ew\|## [Cc]hanges/I,/^##/p' | sed '/^##/d' | sed '/^$/d' | head -n 10)
          fi
          
          # If no changelog content found, use PR title
          if [ -z "$CHANGELOG_CONTENT" ] || [ "$CHANGELOG_CONTENT" = "" ]; then
            CHANGELOG_CONTENT="- $CLEAN_TITLE"
          else
            # Format the content properly (ensure each line starts with -)
            CHANGELOG_CONTENT=$(echo "$CHANGELOG_CONTENT" | sed 's/^/- /' | sed 's/^- -/-/')
          fi
          
          # Create Python script file
          cat > /tmp/update_changelog.py << 'PYEOF'
          import re
          import sys
          import os
          
          version = os.environ.get('VERSION', '')
          date = os.environ.get('DATE', '')
          changelog_content = os.environ.get('CHANGELOG_CONTENT', '')
          
          # Create new changelog entry
          new_entry = f"""## [{version}] - {date}
          
          ### Changes
          {changelog_content}
          
          """
          
          # Read current CHANGELOG
          with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
              content = f.read()
          
          # Find [Unreleased] section and insert after it
          if '## [Unreleased]' in content:
              # Find the end of [Unreleased] section (after the last item before next ##)
              pattern = r'(## \[Unreleased\].*?\n\n)'
              match = re.search(pattern, content, re.DOTALL)
              if match:
                  # Insert new version after [Unreleased] section
                  insert_pos = match.end()
                  content = content[:insert_pos] + new_entry + content[insert_pos:]
              else:
                  # Fallback: insert after [Unreleased] line
                  content = content.replace('## [Unreleased]', f'## [Unreleased]\n\n{new_entry}', 1)
          else:
              # Insert after header (after line 7)
              lines = content.split('\n')
              lines.insert(8, new_entry.strip())
              content = '\n'.join(lines)
          
          # Write updated content
          with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
              f.write(content)
          
          print(f"âœ… Updated CHANGELOG.md with version {version}")
          PYEOF
          
          # Execute Python script with environment variables
          export VERSION="${{ steps.get_version.outputs.version }}"
          export DATE="$DATE"
          export CHANGELOG_CONTENT="$CHANGELOG_CONTENT"
          python3 /tmp/update_changelog.py
          
          echo ""
          echo "ðŸ“‹ New changelog entry preview:"
          head -n 25 CHANGELOG.md

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Create version bump branch and commit
        id: version_bump
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="chore/bump-version-$VERSION"
          
          # Create and checkout new branch
          git checkout -b "$BRANCH_NAME"
          
          # Stage changes
          git add pubspec.yaml CHANGELOG.md
          
          # Commit changes
          git commit -m "chore: bump version to $VERSION [skip ci]"
          
          # Push branch
          git push origin "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.version_bump.outputs.branch }}
          base: main
          title: "chore: bump version to ${{ steps.get_version.outputs.version }} [skip ci]"
          body: |
            This PR was automatically created to bump the version after merging PR #${{ github.event.pull_request.number }}.
            
            **Changes:**
            - Updated `pubspec.yaml` version to `${{ steps.get_version.outputs.version }}`
            - Updated `CHANGELOG.md` with new release entry
            
            This PR will be auto-merged if branch protection allows.
          labels: |
            automated
            chore
          delete-branch: true
          commit-message: "chore: bump version to ${{ steps.get_version.outputs.version }} [skip ci]"
        id: create_pr

      - name: Auto-merge PR (if possible)
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pull-request-number }}"
          echo "Attempting to auto-merge PR #$PR_NUMBER..."
          
          # Try to merge the PR
          if gh pr merge "$PR_NUMBER" --auto --squash; then
            echo "âœ… PR #$PR_NUMBER queued for auto-merge"
            
            # Wait and check if PR was merged (poll up to 30 seconds)
            MAX_WAIT=30
            WAITED=0
            while [ $WAITED -lt $MAX_WAIT ]; do
              sleep 2
              WAITED=$((WAITED + 2))
              PR_STATE=$(gh pr view "$PR_NUMBER" --json state --jq '.state')
              if [ "$PR_STATE" = "MERGED" ]; then
                echo "âœ… PR #$PR_NUMBER successfully merged!"
                echo "merged=true" >> $GITHUB_OUTPUT
                
                # Fetch latest changes
                git fetch origin main
                git checkout main
                git pull origin main
                break
              fi
              echo "Waiting for PR to merge... ($WAITED/$MAX_WAIT seconds)"
            done
            
            if [ "$PR_STATE" != "MERGED" ]; then
              echo "âš ï¸ PR #$PR_NUMBER not merged yet (may require manual approval or more time)"
              echo "merged=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Could not auto-merge PR #$PR_NUMBER (may require manual approval)"
            echo "merged=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        id: auto_merge

      - name: Extract release notes from CHANGELOG
        if: steps.auto_merge.outputs.merged == 'true'
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          # Extract the changelog entry for this version
          RELEASE_NOTES=$(awk "/^## \[$VERSION\]/,/^## \[/" CHANGELOG.md | sed '/^## \[/d' | sed '/^$/d' | head -n 20)
          # Escape for JSON
          RELEASE_NOTES_JSON=$(echo "$RELEASE_NOTES" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag
        if: steps.auto_merge.outputs.merged == 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"
          echo "âœ… Created and pushed tag v$VERSION"

      - name: Create GitHub Release
        if: steps.auto_merge.outputs.merged == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: FlutterForge CLI v${{ steps.get_version.outputs.version }}
          body: |
            ## ðŸš€ What's New in v${{ steps.get_version.outputs.version }}
            
            ${{ steps.release_notes.outputs.notes }}
            
            ---
            
            ### ðŸ“¦ Installation
            
            ```bash
            dart pub global activate --source git https://github.com/victorsdd01/flutter_forge.git
            ```
            
            ### ðŸ”„ Update
            
            ```bash
            flutterforge --update
            ```
            
            ### ðŸ“š Full Changelog
            
            See [CHANGELOG.md](https://github.com/victorsdd01/flutter_forge/blob/main/CHANGELOG.md) for the complete list of changes.
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

