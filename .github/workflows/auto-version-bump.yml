name: Auto Version Bump

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [main]

permissions:
  contents: write
  pull-requests: write

jobs:
  bump-version:
    if: |
      !contains(github.event.pull_request.title, '[skip ci]') &&
      !contains(github.event.pull_request.title, 'chore: bump version') &&
      github.event.pull_request.head.repo.full_name == github.event.pull_request.base.repo.full_name
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          persist-credentials: true

      - name: Check if version bump already done
        id: check_version_bump
        run: |
          # Check if this PR already has a version bump commit
          if git log --oneline --grep="chore: bump version" | head -1 | grep -q "chore: bump version"; then
            echo "‚úÖ Version bump already done in this PR, skipping..."
            echo "already_done=true" >> $GITHUB_OUTPUT
          else
            echo "Version bump needed"
            echo "already_done=false" >> $GITHUB_OUTPUT
          fi
          
          # Always report success to GitHub (so the check passes even if already done)
          echo "‚úÖ Version bump check completed successfully"

      - name: Get current version (for release)
        if: steps.check_version_bump.outputs.already_done == 'false'
        id: current_version
        run: |
          # Fetch main branch to get current version
          git fetch origin main --quiet || true
          # Get version from main branch (the version that will be released)
          CURRENT_VERSION=$(git show origin/main:pubspec.yaml 2>/dev/null | grep "version:" | cut -d " " -f 2 | tr -d '\r' || grep "version:" pubspec.yaml | cut -d " " -f 2 | tr -d '\r')
          echo "Current version (for release): $CURRENT_VERSION"
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Get PR information
        id: pr_info
        run: |
          set -e
          
          # Get PR title and body, handling special characters safely
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          
          # Sanitize variables - remove carriage returns
          PR_TITLE=$(echo "${PR_TITLE}" | tr -d '\r' || echo "")
          PR_BODY=$(echo "${PR_BODY}" | tr -d '\r' || echo "")
          
          echo "PR Title: ${PR_TITLE}"
          
          # Use delimiter to handle multiline content safely
          {
            echo "pr_title<<EOF"
            echo "${PR_TITLE}"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "pr_body<<EOF"
            echo "${PR_BODY}"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Configure Git
        if: steps.check_version_bump.outputs.already_done == 'false'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git config --local pull.rebase false
          git config --local pull.ff only

      - name: Extract release notes from CHANGELOG (current version)
        if: steps.check_version_bump.outputs.already_done == 'false'
        id: release_notes
        run: |
          VERSION="${{ steps.current_version.outputs.version }}"
          # Extract the changelog entry for current version
          RELEASE_NOTES=$(awk "/^## \[$VERSION\]/,/^## \[/" CHANGELOG.md | sed '/^## \[/d' | sed '/^$/d' | head -n 20)
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag (current version)
        if: steps.check_version_bump.outputs.already_done == 'false'
        run: |
          VERSION="${{ steps.current_version.outputs.version }}"
          TAG_NAME="v$VERSION"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag $TAG_NAME already exists, skipping tag creation"
          else
            git tag -a "$TAG_NAME" -m "Release v$VERSION"
            git push origin "$TAG_NAME"
            echo "‚úÖ Created and pushed tag $TAG_NAME"
          fi

      - name: Create GitHub Release (current version)
        if: steps.check_version_bump.outputs.already_done == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.current_version.outputs.version }}
          name: FlutterForge CLI v${{ steps.current_version.outputs.version }}
          body: |
            ## üöÄ What's New in v${{ steps.current_version.outputs.version }}
            
            ${{ steps.release_notes.outputs.notes }}
            
            ---
            
            ### üì¶ Installation
            
            ```bash
            dart pub global activate --source git https://github.com/victorsdd01/flutter_forge.git
            ```
            
            ### üîÑ Update
            
            ```bash
            flutterforge --update
            ```
            
            ### üìö Full Changelog
            
            See [CHANGELOG.md](https://github.com/victorsdd01/flutter_forge/blob/main/CHANGELOG.md) for the complete list of changes.
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate new version
        if: steps.check_version_bump.outputs.already_done == 'false'
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"
          
          # Parse version parts (ej: "1.10.0" -> "1", "10", "0")
          MAJOR=$(echo $CURRENT_VERSION | cut -d '.' -f 1)
          MINOR=$(echo $CURRENT_VERSION | cut -d '.' -f 2)
          PATCH=$(echo $CURRENT_VERSION | cut -d '.' -f 3)
          
          # Increment patch version (1.10.0 -> 1.10.1)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update pubspec.yaml
        if: steps.check_version_bump.outputs.already_done == 'false'
        run: |
          sed -i "s/version:.*/version: ${{ steps.new_version.outputs.version }}/" pubspec.yaml
          echo "Updated pubspec.yaml:"
          grep "version:" pubspec.yaml

      - name: Update CHANGELOG.md
        if: steps.check_version_bump.outputs.already_done == 'false'
        run: |
          VERSION="${{ steps.new_version.outputs.version }}"
          PR_TITLE="${{ steps.pr_info.outputs.pr_title }}"
          PR_BODY="${{ steps.pr_info.outputs.pr_body }}"
          DATE=$(date +%Y-%m-%d)
          
          # Clean PR title (remove version tags like [MINOR], [MAJOR], etc.)
          CLEAN_TITLE=$(echo "$PR_TITLE" | sed 's/\[MINOR\]//g' | sed 's/\[MAJOR\]//g' | sed 's/\[PATCH\]//g' | sed 's/\[SKIP\]//g' | xargs)
          
          # Extract changelog content from PR body if it exists
          CHANGELOG_CONTENT=""
          if echo "$PR_BODY" | grep -qiE "## (Changelog|What's New|Changes)"; then
            # Extract content between ## Changelog/What's New/Changes and next ##
            CHANGELOG_CONTENT=$(echo "$PR_BODY" | sed -n '/## [Cc]hangelog\|## [Ww]hat'\''s [Nn]ew\|## [Cc]hanges/I,/^##/p' | sed '/^##/d' | sed '/^$/d' | head -n 10)
          fi
          
          # If no changelog content found, use PR title
          if [ -z "$CHANGELOG_CONTENT" ] || [ "$CHANGELOG_CONTENT" = "" ]; then
            CHANGELOG_CONTENT="- $CLEAN_TITLE"
          else
            # Format the content properly (ensure each line starts with -)
            CHANGELOG_CONTENT=$(echo "$CHANGELOG_CONTENT" | sed 's/^/- /' | sed 's/^- -/-/')
          fi
          
          # Create Python script file
          cat > /tmp/update_changelog.py << 'PYEOF'
          import re
          import os
          
          version = os.environ.get('VERSION', '')
          date = os.environ.get('DATE', '')
          changelog_content = os.environ.get('CHANGELOG_CONTENT', '')
          
          # Create new changelog entry
          new_entry = f"""## [{version}] - {date}
          
          ### Changes
          {changelog_content}
          
          """
          
          # Read current CHANGELOG
          with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
              content = f.read()
          
          # Find [Unreleased] section and insert after it
          if '## [Unreleased]' in content:
              # Find the end of [Unreleased] section (after the last item before next ##)
              pattern = r'(## \[Unreleased\].*?\n\n)'
              match = re.search(pattern, content, re.DOTALL)
              if match:
                  # Insert new version after [Unreleased] section
                  insert_pos = match.end()
                  content = content[:insert_pos] + new_entry + content[insert_pos:]
              else:
                  # Fallback: insert after [Unreleased] line
                  content = content.replace('## [Unreleased]', f'## [Unreleased]\n\n{new_entry}', 1)
          else:
              # Insert after header (after line 7)
              lines = content.split('\n')
              lines.insert(8, new_entry.strip())
              content = '\n'.join(lines)
          
          # Write updated content
          with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
              f.write(content)
          
          print(f"‚úÖ Updated CHANGELOG.md with version {version}")
          PYEOF
          
          # Execute Python script with environment variables
          export VERSION="${{ steps.new_version.outputs.version }}"
          export DATE="$DATE"
          export CHANGELOG_CONTENT="$CHANGELOG_CONTENT"
          python3 /tmp/update_changelog.py
          
          echo ""
          echo "üìã New changelog entry preview:"
          head -n 25 CHANGELOG.md

      - name: Commit and push version bump to PR branch
        if: steps.check_version_bump.outputs.already_done == 'false'
        run: |
          # Ensure we're on the PR branch and it's up to date
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          git checkout "$BRANCH_NAME"
          
          # Fetch latest changes from remote to avoid conflicts
          git fetch origin "$BRANCH_NAME" --quiet || true
          
          # Try to merge/rebase any remote changes if they exist
          if git rev-parse --verify "origin/$BRANCH_NAME" >/dev/null 2>&1; then
            # Check if we're behind remote
            LOCAL=$(git rev-parse HEAD)
            REMOTE=$(git rev-parse "origin/$BRANCH_NAME" 2>/dev/null || echo "$LOCAL")
            if [ "$LOCAL" != "$REMOTE" ]; then
              echo "‚ö†Ô∏è Branch has remote changes, pulling with merge strategy..."
              git pull origin "$BRANCH_NAME" --no-rebase --no-edit || {
                echo "‚ö†Ô∏è Pull failed, but continuing with local changes..."
              }
            fi
          fi
          
          # Check if version files have changed
          if git diff --quiet pubspec.yaml CHANGELOG.md; then
            echo "‚ö†Ô∏è No changes to version files, skipping commit"
            exit 0
          fi
          
          # Stage only the version files (preserve other changes)
          git add pubspec.yaml CHANGELOG.md
          
          # Commit the version bump
          git commit -m "chore: bump version to ${{ steps.new_version.outputs.version }} [skip ci]"
          
          # Push to PR branch (force-with-lease to prevent overwriting others' work)
          git push origin HEAD:"$BRANCH_NAME" --force-with-lease || {
            echo "‚ö†Ô∏è Force-with-lease failed, trying regular push..."
            git push origin HEAD:"$BRANCH_NAME"
          }
          
          echo "‚úÖ Version bumped to ${{ steps.new_version.outputs.version }} and pushed to PR branch"
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
